# System-on-Chip Design, Clock Domain Crossing, and VHDL GENERATE Statements
## Understanding SoC Concepts, Handling Clock Domains, and Utilizing GENERATE Statements in Hardware Design

This lesson covers System on a Chip (SOC) design, clock domain crossing, and the GENERATE statement in hardware description languages.

An SOC, or System on a Chip, integrates all the necessary electronic circuits for a system into a single chip. This contrasts with traditional systems that use multiple discrete components.

Clock domain crossing (CDC) is a critical aspect of SOC design. It refers to the transfer of data between different parts of a system that operate on different clock signals. This is important because different parts of a complex SOC might need to run at different speeds for optimal performance or power efficiency. The data must be transferred safely and reliably between these different clock domains to avoid errors.

The GENERATE statement is a powerful construct used in hardware description languages (HDLs) to create repetitive structures or conditional logic during the hardware design process. It helps in creating regular or parameterized hardware structures more efficiently than manually writing out the same code multiple times. For example, you might use a GENERATE statement to create an array of identical processing elements or to conditionally include or exclude certain parts of the design. This can help when configuring the SOC or making slight variations to the architecture of the SOC, saving time in writing long portions of code.

To understand clock frequency and ripple counters, let's consider this problem. Imagine we have a digital circuit that divides a clock signal using three flip-flops (FF1, FF2, and FF3) in a ripple-counter configuration. A 25 MHz clock signal is fed into FF1. The goal is to find the lowest clock frequency that can be generated by this ripple counter.

In a ripple counter, each flip-flop divides the frequency of the signal it receives by 2. So, FF1 takes the 25 MHz input clock and divides it by 2. Then, FF2 takes the output of FF1 and divides it by 2 again. Finally, FF3 takes the output of FF2 and divides it by 2 for a final time.
The lowest clock frequency is generated at the final output Q3. This can be expressed mathematically as:

$$f_{output} = \frac{f_{input}}{2^n}$$

where $f_{output}$ is the output frequency, $f_{input}$ is the input frequency and $n$ is the number of flip-flops.

In this particular question we have 3 flip-flops, so n = 3, and $f_{input} = 25 \text{ MHz}$. Therefore, $f_{output}$ can be calculated as:

$$f_{output} = \frac{25 \text{ MHz}}{2^3} = \frac{25 \text{ MHz}}{8} = 3.125 \text{ MHz}$$

Therefore, the lowest clock frequency that can be generated with this ripple counter is 3.125 MHz.

Let's consider another problem involving a 100 MHz clock applied to a VHDL (Very High-Speed Integrated Circuit Hardware Description Language) code that divides the clock. Understanding frequency generation in VHDL involves analyzing the process and how it divides the clock signal.

```vhdl
PROCESS (reset, clock)
BEGIN
  IF reset = '0' THEN
    dividedClock <= '0';
  ELSIF rising_edge(clock) THEN
    dividedClock <= NOT dividedClock;
  ELSIF falling_edge(clock) THEN
    dividedClock <= NOT dividedClock;
  END IF;
END PROCESS;
```

The code describes a process that toggles the `$dividedClock$` signal on both the rising and falling edges of the input `$clock$`. When the reset signal is low, the `$dividedClock$` is forced to '0'. However, in normal operation (when `$reset$` is not active), the `$dividedClock$` signal changes its value (toggles) on *every* rising and falling edge of the input `$clock$`. This has the effect of dividing the frequency by two.

Each full clock cycle of the input `$clock$` has a rising edge *and* a falling edge. Since `$dividedClock$` toggles on *both* edges, it completes a full cycle only after two cycles of the input clock, thus cutting the clock frequency by a factor of 2. The formula to calculate the divided frequency is:

$$f_{divided} = \frac{f_{clock}}{2}$$

Given that $f_{clock} = 100 \text{ MHz}$, the resulting divided clock frequency becomes:

$$f_{divided} = \frac{100 \text{ MHz}}{2} = 50 \text{ MHz}$$

Therefore, the frequency generated from this VHDL code with a 100 MHz input clock is 50 MHz.

Finally, A clock divider can generate signals with any duty cycle where the shortest duration of a pulse equals $\frac{\text{slowClockFrequency}}{\text{fastClockFrequency}}$. For frequency division, toggle mode flip-flops are used in a chain as a divide by two counter. One flip-flop will divide the clock, $f_{IN}$, by 2, two flip-flops will divide $f_{IN}$ by 4 (and so on). One benefit of using toggle flip-flops for frequency division is that the output at any point has an exact 50% duty cycle.

A clock divider can generate duty cycles where the duration of the shortest pulse equals $\frac{\text{slowClockFrequency}}{\text{fastClockFrequency}}$. For frequency division, toggle mode flip-flops are used in a chain as a divide-by-two counter. One flip-flop will divide the clock, $f_{IN}$, by 2, two flip-flops will divide $f_{IN}$ by 4, and so on. One benefit of using toggle flip-flops for frequency division is that the output at any point has an exact 50% duty cycle.

When you are working with different frequency domains, clock domain crossing becomes important. A clock domain is all logic that uses one specific clock, and a clock-domain-crossing occurs if a signal goes to a domain where another clock is used. For example, one part of a system might use a 10 kHz clock, while another part uses a 50 MHz clock.

Clock domain crossing can lead to problems including metastability, data loss, and data incoherency. Metastability occurs when violations of the set-up and hold times happen. When you have a digital signal, there are specific times when you should not look at the digital signal because the signal is not guaranteed to be reliable. There are setup and hold times to account for.

Consider a transition from a digital signal of 0 to 1. From this point on there is a certain amount of time where you shouldn't sample to allow the result to settle. To solve the clock domain crossing issue often "double flopping" is used. Two flip-flops are used in a chain. The idea is that at each resampling of the signal the amount of inaccuracy decreases, and that with more resampling the result becomes stable. This signal that is being resampled is being done at $50 \text{ MHz}$. At the first area, it is said to have a "High Probability of Metatstability." However, with the stability of it now being in the second flip flop, is at a "Low Probability of Metatstability." Even though the double flip-flop method is a great way to use, there is always a chance that this issue could happen again since the two clocks won't be going at the exact same time, there is always a propagation time that is happening, along with having bandwidth limitations.

To deal with metastability in clock domain crossing, "double-flopping" is used. This involves using two flip-flops in series, each operating with a different clock frequency. Imagine transferring data from a slow clock domain, like 10 kHz, to a fast clock domain, like 50 MHz. The first flip-flop, clocked at 10 kHz, samples the input signal. Due to timing uncertainties, the output of the first flip-flop might enter a metastable state. This metastable state is an undefined or unstable state between a definite '0' or '1.' This metastable state might last for an unpredictable amount of time. The purpose of the second flip-flop, clocked at 50 MHz, is to allow enough time for the metastable state to resolve into either a stable '0' or '1' before it is sampled by the faster clock domain. Because the 50 MHz clock is much faster, there is more time to resolve the metastable state before it's captured. This reduces the probability of metastability issues in the higher frequency clock domain. The first flip-flop has a high probability of metastability while the second flip-flop has a low probability of metastability.

Looking at an eye diagram, if sampling is done in the middle of the "eye," where the signal is stable, data integrity is high. If sampling is done where the signal is rapidly transitioning, metastability is more likely.

The lower the frequency is in the low-frequency domain when sampling to a higher frequency, such as 50 MHz, the longer the setup and hold time is. The setup and hold time isn't determined solely by the low-frequency domain but also by the electronics and the specific chip being used. If a standard chip is used, there's a relatively longer setup and hold time. However, if a high-speed chip like the 74HCT01 is used, the setup and hold time is shorter due to the faster switching speed of the chip's electronics. Ultimately, the goal is to filter out the uncertainty when sampling in the metastable region. This is done by using a double-flopping configuration.

After introducing an input signal, there will be a period of metastability before the output signal is stable. Double-flopping works because the metastable period is besampled, and with each successive sampling, it's more likely to be filtered out.
The signal needs to be besampled such that its metastable period gets filtered out. Clock domain crossing is done to reduce the conversion error due to metastability. Note that signals faster than the slow clock will be lost.

Another solution is to stretch the signals into the slow domain. Other solutions to address CDC (clock domain crossing) include using a handshake or a FIFO buffer. When constructing an interface, it is not enough to simply look at the frequency domain, but also the phase domain to ensure that all sampling and the clock signals are on equal footing.

The task is to study examples of the GENERATE statement in VHDL and then execute an assignment using this statement. The general idea is that architecture one, `arch1`, which can be enabled or disabled, uses GENERATE statements to implement a signed multiplier. The exercise involves understanding how these GENERATE statements create hardware. To verify the code, it needs to be compiled and the resulting hardware analyzed using the RTL viewer. A key question is, given a GENERATE statement, what code will it generate? One can check this by compiling the design and using the RTL viewer to see the synthesized hardware. It is important to know that, even though this code can be written sequentially, it is not implemented as sequential logic and is still synthesizable, since GENERATE statement operations are timeless. Three alternative solutions are presented to deal with reversing a bit order in a vector. The first involves constructing a process block, and the second is concatenation. Often, engineers are used to sequential coding, so they tend to gravitate towards sequential style code, whereas GENERATE is concurrent. The key to successfully using GENERATE statements is being comfortable in both concurrent and sequential coding. Furthermore, while there are numerous ways to generate the same hardware, in the end, they all synthesize the same output, although one style might be more efficient compared to another.

In essence, if you perform an action one way and then perform the same action another way, you'll likely observe that the same hardware, in principle, is ultimately synthesized. Someone asked if everyone has tried this. It's important, even if you haven't entirely finished. Let's look at that a little closer.

If you were to build this system, remember that it's useful to draw that for a moment. Assuming you want to build this, with A and B as inputs, you could also synthesize this. It's a simple block, and all you need are NOT gates. You then have a signal with three parts. The problem has to do with those signals. You must generate, within the declarative part, these signals.

You might think that if you are using a signal, it has to appear before. You should start with the generate statement. What's happening now doesn't prepare you for this project.
If you have a generate statement, you need signals, and you must make a signal of a bit vector or $std\_logic\_vector$, say $2 \text{ down to } 0$. Then, you can build these. So, you remain. You clear out the faults yourself.

The key concept being taught is a `generate` statement in VHDL. The code `architecture arch1 of theoryClassExc_005 is signal a,b: BIT_VECTOR(7 DOWNTO 0);` declares an architecture named `arch1` for the entity `theoryClassExc_005`. Inside, it declares two signals `a` and `b` as bit vectors, each with a size of 8 bits (indexed from 7 down to 0). This means `a` and `b` can hold 8 binary values.

The code then shows three examples of `generate` statements:

**Example 1:**
```vhdl
gen: for i in 0 to 7 generate
  x(i) <= a(i) xor b(7-i);
end generate;
```
This `generate` statement creates eight XOR gates. The loop variable `i` ranges from 0 to 7. For each value of `i`, it connects input `a(i)` to an XOR gate, along with input `b(7-i)`. The result of the XOR operation is assigned to the output `x(i)`. This effectively XORs corresponding bits of `a` with the reversed order of bits of `b`.

**Example 2:**
```vhdl
gen: for i in 1 to 4 generate
  x(i) <= a(i) xor b(7-i);
end generate;
```
This generate statement will create four XOR gates where the variable `i` ranges from 1 to 4. It connects `a(i)` to the XOR gate along with `b(7-i)`, and then outputs the result to `x(i)`. This example is similar to Example 1, but with different iteration bounds creating less gates (from the second index to the fifth).

**Example 3:**
```vhdl
gen: for i in a'REVERSE_RANGE generate
  x(i) <= a(i) xor b(7-i);
end generate;
```
The final example uses the `REVERSE_RANGE` attribute. This `generate` statement iterates through the indices of `a` in reverse order. The loop variable `i` takes values from 7 down to 0. The XOR operation is still performed between `a(i)` and `b(7-i)`, and the result is assigned to `x(i)`.

The general idea in VHDL is that you can also handle these (groups of signals) individually, and you can treat them individually as a bundle. The different examples of generate statements given above will synthesize to the same hardware in principle, but demonstrates differing ways of describing the hardware.

Finally, the code includes the signal declaration, `signal a,b: BIT_VECTOR(7 DOWNTO 0);`. This indicates the data type for the signals `a` and `b` which are 8-bit vectors where each bit has a value that is high or low, represented in the programming language via `bit_vector`.

The lecturer suggests to connect A to $C_0$, but then wonders where the signal would come from; this serves as a question for the audience. You can use many strategies. In principle you would have three threads and vector C; STD logic vector; $2 \text{ down to } 0$. What they do doesn't prepare them for the exercise but they can make it. The signal needs a signal in the bit vector or $std\_logic\_vector$. It's important the topic should go through the exercise.

In summary, the `generate` statement is a powerful construct in VHDL that allows for the creation of repetitive hardware structures based on loop iterations. The examples showcase the ability to create XOR gate arrangements, reverse the order of signals during processing, and bundle signals within a generate statement for later use. You can take the signal you have; three different signals are being made, but you can approach it a different way, you can handle these "loose threads" as a bundle, they can also be treated by losing strands.

VHDL architecture can be constructed with `GENERATE` statements. Here are some examples. The first example shows how to generate a bitwise XOR operation. We have signals `$a$` and `$b$`, which are bit vectors ranging from 7 down to 0. We then have a `GEN` label for the generate statement, looping `$i$` from 0 to 7. Inside the generate statement, we assign the XOR of `$a(i)$` and `$b(7-i)$` to `$x(i)$`. This creates a bitwise XOR with a reversed order of the bits of `$b$`. The second example uses `GENERATE` similarly. Here, `$x(i)$` becomes `$a(i)$` XORed with `$b(i)$`, generating a bitwise XOR. The third example is almost the same as the second, but this time a `REVERSE_RANGE` is used, so it loops `$i$` in reverse order, assigning `$x(i)$` to `$a(i)$` XORed with `$b(7-i)$`.

A design may have multiple architectural implementations (`arch1`, `arch2`). To select which architecture to use, you can use a `CONFIGURATION` block, specifically targeting the `theoryClassExc_005` entity. Within the configuration, you can specify `for arch1`, indicating the use of the first architecture. Alternatively, you can use `for arch2` to select the second architecture. The architecture selection is achieved by uncommenting the relevant `CONFIGURATION` block in the Very-high-speed integrated circuit Hardware Description Language(VHDL) code to include it for compilation. A `keep` attribute is also used. This attribute is for Altera and is used to prevent the compiler from optimizing out parts that have this statement. This can introduce a static delay into a signal because the value has to make it from point A to point B. Using $for$ $i$ $in$ a C attribute range, you then generate. So therefore for $i$ and C means $A$ right sign not c($i+ 1$). But C you have assigned not A, so then A has only assigned not c. The compiler doesn't do that. The point of general statement, Hardware description to make what happened. With generate code we are going to high level used. The vector is a better way. Also want to avoid and that where not so you get the same output. This uses double negative so to say.

The instructor is scheduling the dates and times of student oral exams. The oral exams are scheduled for in-person meetings rather than virtual. The exams will take place either on June 17th or on July 1st of the next year (2025). The schedule depends on student availability, and there are about three people who want to schedule their oral exam for July 1st. The students must submit their work one week before their chosen examination date. For example, if a student wishes to take the oral exam on July 1st, the assignment must be submitted by June 24th. If the student chooses June 17th as their oral exam day, the assignment must be submitted by June 10th. During their oral exam, students will be expected to physically demonstrate any hardware or designs they created for the assignment. One student keyboard that was lent out also needs to be returned. The instructor indicates that he will confirm all dates and times via email. The presentation also displays the "generate statement" assignment, linking to a GitLab repository. Students are told to study the examples provided and execute the assignment.
